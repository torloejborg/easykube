// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/ez/container_runtime.go
//
// Generated by this command:
//
//	mockgen -typed --source pkg/ez/container_runtime.go --destination mocks/m_container_runtime.go
//

// Package mock_ez is a generated GoMock package.
package mock_ez

import (
	reflect "reflect"

	ez "github.com/torloejborg/easykube/pkg/ez"
	gomock "go.uber.org/mock/gomock"
)

// MockIContainerRuntime is a mock of IContainerRuntime interface.
type MockIContainerRuntime struct {
	ctrl     *gomock.Controller
	recorder *MockIContainerRuntimeMockRecorder
	isgomock struct{}
}

// MockIContainerRuntimeMockRecorder is the mock recorder for MockIContainerRuntime.
type MockIContainerRuntimeMockRecorder struct {
	mock *MockIContainerRuntime
}

// NewMockIContainerRuntime creates a new mock instance.
func NewMockIContainerRuntime(ctrl *gomock.Controller) *MockIContainerRuntime {
	mock := &MockIContainerRuntime{ctrl: ctrl}
	mock.recorder = &MockIContainerRuntimeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIContainerRuntime) EXPECT() *MockIContainerRuntimeMockRecorder {
	return m.recorder
}

// CloseContainerRuntime mocks base method.
func (m *MockIContainerRuntime) CloseContainerRuntime() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseContainerRuntime")
}

// CloseContainerRuntime indicates an expected call of CloseContainerRuntime.
func (mr *MockIContainerRuntimeMockRecorder) CloseContainerRuntime() *MockIContainerRuntimeCloseContainerRuntimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseContainerRuntime", reflect.TypeOf((*MockIContainerRuntime)(nil).CloseContainerRuntime))
	return &MockIContainerRuntimeCloseContainerRuntimeCall{Call: call}
}

// MockIContainerRuntimeCloseContainerRuntimeCall wrap *gomock.Call
type MockIContainerRuntimeCloseContainerRuntimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeCloseContainerRuntimeCall) Return() *MockIContainerRuntimeCloseContainerRuntimeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeCloseContainerRuntimeCall) Do(f func()) *MockIContainerRuntimeCloseContainerRuntimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeCloseContainerRuntimeCall) DoAndReturn(f func()) *MockIContainerRuntimeCloseContainerRuntimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockIContainerRuntime) Commit(containerID string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Commit", containerID)
}

// Commit indicates an expected call of Commit.
func (mr *MockIContainerRuntimeMockRecorder) Commit(containerID any) *MockIContainerRuntimeCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockIContainerRuntime)(nil).Commit), containerID)
	return &MockIContainerRuntimeCommitCall{Call: call}
}

// MockIContainerRuntimeCommitCall wrap *gomock.Call
type MockIContainerRuntimeCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeCommitCall) Return() *MockIContainerRuntimeCommitCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeCommitCall) Do(f func(string)) *MockIContainerRuntimeCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeCommitCall) DoAndReturn(f func(string)) *MockIContainerRuntimeCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ContainerWriteFile mocks base method.
func (m *MockIContainerRuntime) ContainerWriteFile(containerId, dst, filename string, data []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ContainerWriteFile", containerId, dst, filename, data)
}

// ContainerWriteFile indicates an expected call of ContainerWriteFile.
func (mr *MockIContainerRuntimeMockRecorder) ContainerWriteFile(containerId, dst, filename, data any) *MockIContainerRuntimeContainerWriteFileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContainerWriteFile", reflect.TypeOf((*MockIContainerRuntime)(nil).ContainerWriteFile), containerId, dst, filename, data)
	return &MockIContainerRuntimeContainerWriteFileCall{Call: call}
}

// MockIContainerRuntimeContainerWriteFileCall wrap *gomock.Call
type MockIContainerRuntimeContainerWriteFileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeContainerWriteFileCall) Return() *MockIContainerRuntimeContainerWriteFileCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeContainerWriteFileCall) Do(f func(string, string, string, []byte)) *MockIContainerRuntimeContainerWriteFileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeContainerWriteFileCall) DoAndReturn(f func(string, string, string, []byte)) *MockIContainerRuntimeContainerWriteFileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateContainerRegistry mocks base method.
func (m *MockIContainerRuntime) CreateContainerRegistry() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateContainerRegistry")
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateContainerRegistry indicates an expected call of CreateContainerRegistry.
func (mr *MockIContainerRuntimeMockRecorder) CreateContainerRegistry() *MockIContainerRuntimeCreateContainerRegistryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateContainerRegistry", reflect.TypeOf((*MockIContainerRuntime)(nil).CreateContainerRegistry))
	return &MockIContainerRuntimeCreateContainerRegistryCall{Call: call}
}

// MockIContainerRuntimeCreateContainerRegistryCall wrap *gomock.Call
type MockIContainerRuntimeCreateContainerRegistryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeCreateContainerRegistryCall) Return(arg0 error) *MockIContainerRuntimeCreateContainerRegistryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeCreateContainerRegistryCall) Do(f func() error) *MockIContainerRuntimeCreateContainerRegistryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeCreateContainerRegistryCall) DoAndReturn(f func() error) *MockIContainerRuntimeCreateContainerRegistryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockIContainerRuntime) Exec(containerId string, cmd []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Exec", containerId, cmd)
}

// Exec indicates an expected call of Exec.
func (mr *MockIContainerRuntimeMockRecorder) Exec(containerId, cmd any) *MockIContainerRuntimeExecCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIContainerRuntime)(nil).Exec), containerId, cmd)
	return &MockIContainerRuntimeExecCall{Call: call}
}

// MockIContainerRuntimeExecCall wrap *gomock.Call
type MockIContainerRuntimeExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeExecCall) Return() *MockIContainerRuntimeExecCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeExecCall) Do(f func(string, []string)) *MockIContainerRuntimeExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeExecCall) DoAndReturn(f func(string, []string)) *MockIContainerRuntimeExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindContainer mocks base method.
func (m *MockIContainerRuntime) FindContainer(name string) (*ez.ContainerSearch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindContainer", name)
	ret0, _ := ret[0].(*ez.ContainerSearch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindContainer indicates an expected call of FindContainer.
func (mr *MockIContainerRuntimeMockRecorder) FindContainer(name any) *MockIContainerRuntimeFindContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindContainer", reflect.TypeOf((*MockIContainerRuntime)(nil).FindContainer), name)
	return &MockIContainerRuntimeFindContainerCall{Call: call}
}

// MockIContainerRuntimeFindContainerCall wrap *gomock.Call
type MockIContainerRuntimeFindContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeFindContainerCall) Return(arg0 *ez.ContainerSearch, arg1 error) *MockIContainerRuntimeFindContainerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeFindContainerCall) Do(f func(string) (*ez.ContainerSearch, error)) *MockIContainerRuntimeFindContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeFindContainerCall) DoAndReturn(f func(string) (*ez.ContainerSearch, error)) *MockIContainerRuntimeFindContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasImage mocks base method.
func (m *MockIContainerRuntime) HasImage(image string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasImage", image)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasImage indicates an expected call of HasImage.
func (mr *MockIContainerRuntimeMockRecorder) HasImage(image any) *MockIContainerRuntimeHasImageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasImage", reflect.TypeOf((*MockIContainerRuntime)(nil).HasImage), image)
	return &MockIContainerRuntimeHasImageCall{Call: call}
}

// MockIContainerRuntimeHasImageCall wrap *gomock.Call
type MockIContainerRuntimeHasImageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeHasImageCall) Return(arg0 bool) *MockIContainerRuntimeHasImageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeHasImageCall) Do(f func(string) bool) *MockIContainerRuntimeHasImageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeHasImageCall) DoAndReturn(f func(string) bool) *MockIContainerRuntimeHasImageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasImageInKindRegistry mocks base method.
func (m *MockIContainerRuntime) HasImageInKindRegistry(name string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasImageInKindRegistry", name)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasImageInKindRegistry indicates an expected call of HasImageInKindRegistry.
func (mr *MockIContainerRuntimeMockRecorder) HasImageInKindRegistry(name any) *MockIContainerRuntimeHasImageInKindRegistryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasImageInKindRegistry", reflect.TypeOf((*MockIContainerRuntime)(nil).HasImageInKindRegistry), name)
	return &MockIContainerRuntimeHasImageInKindRegistryCall{Call: call}
}

// MockIContainerRuntimeHasImageInKindRegistryCall wrap *gomock.Call
type MockIContainerRuntimeHasImageInKindRegistryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeHasImageInKindRegistryCall) Return(arg0 bool) *MockIContainerRuntimeHasImageInKindRegistryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeHasImageInKindRegistryCall) Do(f func(string) bool) *MockIContainerRuntimeHasImageInKindRegistryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeHasImageInKindRegistryCall) DoAndReturn(f func(string) bool) *MockIContainerRuntimeHasImageInKindRegistryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsClusterRunning mocks base method.
func (m *MockIContainerRuntime) IsClusterRunning() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClusterRunning")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClusterRunning indicates an expected call of IsClusterRunning.
func (mr *MockIContainerRuntimeMockRecorder) IsClusterRunning() *MockIContainerRuntimeIsClusterRunningCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClusterRunning", reflect.TypeOf((*MockIContainerRuntime)(nil).IsClusterRunning))
	return &MockIContainerRuntimeIsClusterRunningCall{Call: call}
}

// MockIContainerRuntimeIsClusterRunningCall wrap *gomock.Call
type MockIContainerRuntimeIsClusterRunningCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeIsClusterRunningCall) Return(arg0 bool) *MockIContainerRuntimeIsClusterRunningCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeIsClusterRunningCall) Do(f func() bool) *MockIContainerRuntimeIsClusterRunningCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeIsClusterRunningCall) DoAndReturn(f func() bool) *MockIContainerRuntimeIsClusterRunningCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsContainerRunning mocks base method.
func (m *MockIContainerRuntime) IsContainerRunning(containerID string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsContainerRunning", containerID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsContainerRunning indicates an expected call of IsContainerRunning.
func (mr *MockIContainerRuntimeMockRecorder) IsContainerRunning(containerID any) *MockIContainerRuntimeIsContainerRunningCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsContainerRunning", reflect.TypeOf((*MockIContainerRuntime)(nil).IsContainerRunning), containerID)
	return &MockIContainerRuntimeIsContainerRunningCall{Call: call}
}

// MockIContainerRuntimeIsContainerRunningCall wrap *gomock.Call
type MockIContainerRuntimeIsContainerRunningCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeIsContainerRunningCall) Return(arg0 bool) *MockIContainerRuntimeIsContainerRunningCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeIsContainerRunningCall) Do(f func(string) bool) *MockIContainerRuntimeIsContainerRunningCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeIsContainerRunningCall) DoAndReturn(f func(string) bool) *MockIContainerRuntimeIsContainerRunningCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsContainerRuntimeAvailable mocks base method.
func (m *MockIContainerRuntime) IsContainerRuntimeAvailable() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsContainerRuntimeAvailable")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsContainerRuntimeAvailable indicates an expected call of IsContainerRuntimeAvailable.
func (mr *MockIContainerRuntimeMockRecorder) IsContainerRuntimeAvailable() *MockIContainerRuntimeIsContainerRuntimeAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsContainerRuntimeAvailable", reflect.TypeOf((*MockIContainerRuntime)(nil).IsContainerRuntimeAvailable))
	return &MockIContainerRuntimeIsContainerRuntimeAvailableCall{Call: call}
}

// MockIContainerRuntimeIsContainerRuntimeAvailableCall wrap *gomock.Call
type MockIContainerRuntimeIsContainerRuntimeAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeIsContainerRuntimeAvailableCall) Return(arg0 bool) *MockIContainerRuntimeIsContainerRuntimeAvailableCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeIsContainerRuntimeAvailableCall) Do(f func() bool) *MockIContainerRuntimeIsContainerRuntimeAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeIsContainerRuntimeAvailableCall) DoAndReturn(f func() bool) *MockIContainerRuntimeIsContainerRuntimeAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsNetworkConnectedToContainer mocks base method.
func (m *MockIContainerRuntime) IsNetworkConnectedToContainer(containerID, networkID string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsNetworkConnectedToContainer", containerID, networkID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsNetworkConnectedToContainer indicates an expected call of IsNetworkConnectedToContainer.
func (mr *MockIContainerRuntimeMockRecorder) IsNetworkConnectedToContainer(containerID, networkID any) *MockIContainerRuntimeIsNetworkConnectedToContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNetworkConnectedToContainer", reflect.TypeOf((*MockIContainerRuntime)(nil).IsNetworkConnectedToContainer), containerID, networkID)
	return &MockIContainerRuntimeIsNetworkConnectedToContainerCall{Call: call}
}

// MockIContainerRuntimeIsNetworkConnectedToContainerCall wrap *gomock.Call
type MockIContainerRuntimeIsNetworkConnectedToContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeIsNetworkConnectedToContainerCall) Return(arg0 bool) *MockIContainerRuntimeIsNetworkConnectedToContainerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeIsNetworkConnectedToContainerCall) Do(f func(string, string) bool) *MockIContainerRuntimeIsNetworkConnectedToContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeIsNetworkConnectedToContainerCall) DoAndReturn(f func(string, string) bool) *MockIContainerRuntimeIsNetworkConnectedToContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NetworkConnect mocks base method.
func (m *MockIContainerRuntime) NetworkConnect(containerId, networkId string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NetworkConnect", containerId, networkId)
}

// NetworkConnect indicates an expected call of NetworkConnect.
func (mr *MockIContainerRuntimeMockRecorder) NetworkConnect(containerId, networkId any) *MockIContainerRuntimeNetworkConnectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkConnect", reflect.TypeOf((*MockIContainerRuntime)(nil).NetworkConnect), containerId, networkId)
	return &MockIContainerRuntimeNetworkConnectCall{Call: call}
}

// MockIContainerRuntimeNetworkConnectCall wrap *gomock.Call
type MockIContainerRuntimeNetworkConnectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeNetworkConnectCall) Return() *MockIContainerRuntimeNetworkConnectCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeNetworkConnectCall) Do(f func(string, string)) *MockIContainerRuntimeNetworkConnectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeNetworkConnectCall) DoAndReturn(f func(string, string)) *MockIContainerRuntimeNetworkConnectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PullImage mocks base method.
func (m *MockIContainerRuntime) PullImage(image string, privateRegistryCredentials *string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PullImage", image, privateRegistryCredentials)
}

// PullImage indicates an expected call of PullImage.
func (mr *MockIContainerRuntimeMockRecorder) PullImage(image, privateRegistryCredentials any) *MockIContainerRuntimePullImageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullImage", reflect.TypeOf((*MockIContainerRuntime)(nil).PullImage), image, privateRegistryCredentials)
	return &MockIContainerRuntimePullImageCall{Call: call}
}

// MockIContainerRuntimePullImageCall wrap *gomock.Call
type MockIContainerRuntimePullImageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimePullImageCall) Return() *MockIContainerRuntimePullImageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimePullImageCall) Do(f func(string, *string)) *MockIContainerRuntimePullImageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimePullImageCall) DoAndReturn(f func(string, *string)) *MockIContainerRuntimePullImageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PushImage mocks base method.
func (m *MockIContainerRuntime) PushImage(image string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PushImage", image)
}

// PushImage indicates an expected call of PushImage.
func (mr *MockIContainerRuntimeMockRecorder) PushImage(image any) *MockIContainerRuntimePushImageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushImage", reflect.TypeOf((*MockIContainerRuntime)(nil).PushImage), image)
	return &MockIContainerRuntimePushImageCall{Call: call}
}

// MockIContainerRuntimePushImageCall wrap *gomock.Call
type MockIContainerRuntimePushImageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimePushImageCall) Return() *MockIContainerRuntimePushImageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimePushImageCall) Do(f func(string)) *MockIContainerRuntimePushImageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimePushImageCall) DoAndReturn(f func(string)) *MockIContainerRuntimePushImageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveContainer mocks base method.
func (m *MockIContainerRuntime) RemoveContainer(id string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveContainer", id)
}

// RemoveContainer indicates an expected call of RemoveContainer.
func (mr *MockIContainerRuntimeMockRecorder) RemoveContainer(id any) *MockIContainerRuntimeRemoveContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveContainer", reflect.TypeOf((*MockIContainerRuntime)(nil).RemoveContainer), id)
	return &MockIContainerRuntimeRemoveContainerCall{Call: call}
}

// MockIContainerRuntimeRemoveContainerCall wrap *gomock.Call
type MockIContainerRuntimeRemoveContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeRemoveContainerCall) Return() *MockIContainerRuntimeRemoveContainerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeRemoveContainerCall) Do(f func(string)) *MockIContainerRuntimeRemoveContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeRemoveContainerCall) DoAndReturn(f func(string)) *MockIContainerRuntimeRemoveContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartContainer mocks base method.
func (m *MockIContainerRuntime) StartContainer(id string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StartContainer", id)
}

// StartContainer indicates an expected call of StartContainer.
func (mr *MockIContainerRuntimeMockRecorder) StartContainer(id any) *MockIContainerRuntimeStartContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartContainer", reflect.TypeOf((*MockIContainerRuntime)(nil).StartContainer), id)
	return &MockIContainerRuntimeStartContainerCall{Call: call}
}

// MockIContainerRuntimeStartContainerCall wrap *gomock.Call
type MockIContainerRuntimeStartContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeStartContainerCall) Return() *MockIContainerRuntimeStartContainerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeStartContainerCall) Do(f func(string)) *MockIContainerRuntimeStartContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeStartContainerCall) DoAndReturn(f func(string)) *MockIContainerRuntimeStartContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StopContainer mocks base method.
func (m *MockIContainerRuntime) StopContainer(id string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopContainer", id)
}

// StopContainer indicates an expected call of StopContainer.
func (mr *MockIContainerRuntimeMockRecorder) StopContainer(id any) *MockIContainerRuntimeStopContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopContainer", reflect.TypeOf((*MockIContainerRuntime)(nil).StopContainer), id)
	return &MockIContainerRuntimeStopContainerCall{Call: call}
}

// MockIContainerRuntimeStopContainerCall wrap *gomock.Call
type MockIContainerRuntimeStopContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeStopContainerCall) Return() *MockIContainerRuntimeStopContainerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeStopContainerCall) Do(f func(string)) *MockIContainerRuntimeStopContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeStopContainerCall) DoAndReturn(f func(string)) *MockIContainerRuntimeStopContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TagImage mocks base method.
func (m *MockIContainerRuntime) TagImage(source, target string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TagImage", source, target)
}

// TagImage indicates an expected call of TagImage.
func (mr *MockIContainerRuntimeMockRecorder) TagImage(source, target any) *MockIContainerRuntimeTagImageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagImage", reflect.TypeOf((*MockIContainerRuntime)(nil).TagImage), source, target)
	return &MockIContainerRuntimeTagImageCall{Call: call}
}

// MockIContainerRuntimeTagImageCall wrap *gomock.Call
type MockIContainerRuntimeTagImageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIContainerRuntimeTagImageCall) Return() *MockIContainerRuntimeTagImageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIContainerRuntimeTagImageCall) Do(f func(string, string)) *MockIContainerRuntimeTagImageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIContainerRuntimeTagImageCall) DoAndReturn(f func(string, string)) *MockIContainerRuntimeTagImageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
