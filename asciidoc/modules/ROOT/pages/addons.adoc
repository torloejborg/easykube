= Addons [[addons-addons]]
:icons: font
:source-highlighter: rouge

== Addon repositories [[addons-repositories]]

In essence, an addon is a collection of Kubernetes YAML files, Kustomize files, or Helm charts, orchestrated by JavaScript, with built-in dependency management and convenient tooling.

Addons are organized in directory structures, typically Git repositories shared within an organization or team. Below is an excerpt from the companion addon repository.

[source,text]
├── __jslib <1>
│ ├── 1-easykube.js
│ ├── 2-postgres.js
│ ├── 3-utils.js
│ └── readme.md
├── middleware
│ ├── ingress
│ │ ├── ingress.ek.js <2>
│ │ ├── kustomization.yaml
│ │ └── manifests
│ │ ├── default-cert.yaml
│ │ ├── ingress-controller.yaml
│ │ └── namespace.yaml

<1> The jslib is a core component of a repository. Here, the easykube API is defined as a JavaScript class that wraps function calls and delegates to the _ek object exposed by the Go program. You can write common functionality and place it in this folder.

<2> The addon script determines how the manifests will be applied. In this example we can see that regular Kubernetes YAML files live in subdirectories.

When easykube is invoked, it recursively scans the addon repository and discovers all addons.

=== Dissecting an Addon [[addons-dissecting]]

Let's examine an addon in detail. We'll look at the Temporal addon, as it uses some non-trivial features. Below is its listing:

[source,javascript,linenums]
----
let configuration = { //<1>
"description": "An opensource workflow engine", //<2>
"dependsOn" : [ "postgres", "Ingress" ],
"extraPorts" : [ //<3>
{
"hostPort" : 7233,
"nodePort" : 30950,
"protocol" : "TCP"
}]
}

let deployment = "temporal-server"
let namespace = "default"

postgres.create("temporal") //<4>

const images = new Map([ //<5>
["temporalio/auto-setup:1.22.1.0", "localhost:5001/temporalio/auto-setup:1.22.1.0"],
["temporalio/ui:2.19.0", "localhost:5001/temporalio/ui:2.19.0"]
])

easykube
.preload(images) //<6>
.kustomize() //<7>
.waitForDeployment(deployment, namespace) //<8>

easykube.runCommand(deployment, namespace, "tctl", ["--ns", "namespace-a", "n", "re"]) //<9>
.onSuccess((r)=>{console.info(r)})
.onFail((e)=>{console.warn(e)})

easykube.runCommand(deployment, namespace, "tctl", ["--ns", "namespace-b", "n", "re"])
.onSuccess((r)=>{console.info(r)})
.onFail((e)=>{console.warn(e)})
----

A lot is happening here, so let’s break it down:

<1> Every addon has a configuration directive. This JSON structure is extracted by the main easykube program and used to construct the Kind cluster configuration.

<2> [[addons-dependencies]]Addons allow you to express dependencies on other addons. In this case, the Temporal addon requires a database and an ingress controller for its UI. Internally, during addon scanning, a dependency graph is created and a topological sort determines the installation order—similar to a build system where tasks depend on other tasks.

<3> The extraPorts section contributes to the cluster configuration. Your deployments should define a NodePort service using the same values, but only if the deployment needs to be accessible from your host machine (localhost). In this case, Temporal becomes available on 127.0.0.1:7233.

<4> Easykube’s public addon repository includes a Postgres database server. This instructs Postgres to create a database named temporal (if it doesn’t already exist). Utility functions related to Postgres live in the file 2-postgres.js.

<5> A map of images defines a source and destination.

<6> Images are fetched from the internet, re-tagged, and pushed to the local Docker registry. Easykube will not pull images if they already exist in the registry, saving time (at the expense of disk usage). Local deployments refer to images stored in the registry.

<7> Invoking kustomize renders the manifests to a file named .out.yaml and applies them using kubectl.

<8> waitForDeployment halts execution until the specified deployment becomes ready (with a 30-second timeout). This is useful in local scenarios where we may need to wait for a database to finish initializing. Real workloads should use better readiness strategies.

<9> Running arbitrary commands inside a container is a useful feature. In this example, the Temporal deployment requires namespace-a and namespace-b to exist. This mechanism can be used to load test data into a database, create a token inside a container and store it as a Kubernetes secret, and more.

== Limitations [[addons-limitations]]

It may appear that the jslib is some sort of global context, but this is not the case. Every addon is executed in its own isolated context. jslib files are simply concatenated and evaluated inside that context.

This means you cannot share or maintain global state between addons during script execution.

== Author a new addon [[addons-author]]

To write your own addon, copy/paste is a reasonable strategy. Alternatively, you can use the built-in skaffold generator:

`$ easkube skaffold --name myaddon --location utils`

This generates a simple addon skeleton you can adapt for your own purposes. The location parameter is relative to the root of the addon repository.

