= Rationale [[rationale-rationale]]

* Easykube aims to enable shared development "platforms" via its companion addon repositories.

* If Kubernetes are used for workloads, why not re-use the stuff already written? The devops team must have produced something you can reuse.. Experiment, develop locally. Breaking "the system" - Eliminate the "docker-compose" shadow workflow.

* Easykube is designed to be a team and individual enabler: Everyone can install and work with a cloud-native application’s particular stack  locally, without breaking any shared environment.

== What is it? [[rationale-easykube]]

* Easykube is built using the https://kind.sigs.k8s.io/[Kind] project (Kubernetes in Docker) and the https://github.com/dop251/goja[Goja] JavaScript runtime Go library.

* It bootstraps a single-node Kind cluster with opinionated modifications.

* It automatically sets up a local Docker registry for the cluster and connects it locally, permits air-gapped environments.

* Based on available addons, a Kind cluster configuration is generated for the particular addon repository’s use case. Port forwarding and storage requirements are handled automatically.

* Persistent data (if used) survives cluster deletion and recreation. Databases remain intact - real databases, with indexes and everything, no in-memory nonsense.

* Addon installation is programmable via the embedded JavaScript library. Highly customizable, extensible; Provision databases, caches, inject secrets, patch deployments - It's local, do anything, break everything!

* Easykube has built-in dependency resolution. Addons can depend on other addons. If you have a large-ish system, you can choose to install the parts you need.

* A CoreDNS hack lets you access everything from "localtest.me" — never touch the /etc/hosts (or that c:\windows\system32\drivers\etc\hosts) file again. If your addon workloads define 100+ ingresses, you can still make everything work locally.

== Easykube helps you with[[rationale-dowith]]

* Enabling your team to install and run your cloud-native application(s) locally.

* Break things; it’s OK. Just start over - We learn everyday!

* Effortlessly spin up local development stacks: Databases, Web servers, Caches, Workflow engines, OAuth servers, S3-compatible storage - If it runs in kubernetes (or Docker/Podman) -  It runs on Easykube.

* Kubernetes can be complicated, use Easykube as a gateway-drug for new team members - Let them experience the challenges of distributed systems firsthand, on their own machines.

* Perhaps some team members refuse to acknowledge the 'cloud' thing, they are brilliant developers, but will never care about Kubernetes — That’s OK, no one can be forced to like YAML (it's just a runtime thing anyway).

** `$ easykube add mystack` seems like a good tradeoff; Stuff runs, we can figure why things explode before we pay our pensions to a random cloud-provider, all because of an endless loop..

** Consider the request chain: (Ingress) -> A -> B -> (queue) -> C.
 If you ever had to debug what broke in "C". If you know the pain, you experienced the late night sessions. Otherwise, proceed to be happy.

* Become a smart-arse, now you can finally prove, without a doubt, that the pesky devops team has been wrong about everything, Kubernetes is written in Golang, nobody knows Golang better than you!

== Torches and spanners

**If you live in a permissive environment and have the freedom to install the tooling mentioned below, then Easykube might not be for you. Consider your options.**

However, working in a constrained environment, your cluster-admin will plain out refuse your request of "Hey, let me install this awesome operator in your cluster, it does stuff like intercept and redirect network traffic, and it can do tricky things the pods.."

Nope. Go away. Play your games elsewhere. I will never let this happen - Even in the dev cluster.

Harsh, but a fair statement.

However. Locally we are (mostly) free to do things. We develop, we experiment, we break things, we amend. Easykube paired with some extra tooling, one option being; 'mirrord' goes extremely well in a local setup. (alternatives do exist)

**Disclaimer; I am not associated with the mirrord product and the Metalbear company. I just think what they are doing is neat.**

Use mirrord (or equivalent) to do fast local (or remote) iterations, avoid the `compile -> construct image -> deploy -> wait -> repeat cycle.`

Kubernetes is all about orchestrating containers, not live software. However, with specialized tooling we can have an ergonomic developer experience.

== When not to use Easykube [[rationale-donot]]

* Not using kubernetes.

* If you have a multitude of microservices (say, 20+) - Easykube might not be the thing you are looking for (unless developers are issued powerful machines). Continue putting credits in the cloud providers slot machine.

* Never, ever, spin up easykube in a production setting, or use it for something really important. It's meant for trashing; Try, fail, start over.  Run your real workloads on a secured cluster. Easykube is built for local development only.
