= Addons [[addons-addons]]
:icons: font

The sections below will foucs on how to use easykube, general usage and addons are explained. To understand what problem easykube solves, we must first visit the _addon_.

== Addon repositories [[addons-repositories]]
In essence, an addon is a collection of kubernetes yaml files, kustomize files or helm charts, orchestrated by a javascript, with _built-in dependency management_ and convenient tooling.

Addons are organized in directory structures, they are typically git-repositories shared in an organization or team. Below is an except of a listing from the companion addon repo.

----
├── __jslib <1>
│   ├── 1-easykube.js
│   ├── 2-postgres.js
│   ├── 3-utils.js
│   └── readme.md
├── middleware
│   ├── ingress
│   │   ├── ingress.ek.js <2>
│   │   ├── kustomization.yaml
│   │   └── manifests
│   │       ├── default-cert.yaml
│   │       ├── ingress-controller.yaml
│   │       └── namespace.yaml
----
<1> The jslib is a core component of a repository, here the easykube _api_ is defined a Javascript class wraps function calls and delegate to an *_ek* object exposed from the go program. You can write common functionality and put it in this folder.

<2> The addon script; It decides how the manifests will be applied. In this example we can see that regular kubernetes yaml files lives in subdirectories.

When easykube is invoked, it will recursively scan the addon repository and discover all addons.

=== Dissecting an Addon [[addons-dissecting]]

Let's examine an addon in detail, we'll look at the temporal addon, as it uses some non-trivial features. Below is its listing.

[source,javascript]
----
let configuration = { //<1>
    "description": "An opensource workflow engine", //<2>
    "dependsOn" : [ "postgres", "ingress" ],
    "extraPorts" : [ //<3>
    {
        "hostPort" : 7233,
        "nodePort" : 30950,
        "protocol" : "TCP"
    }]
}

let deployment = "temporal-server"
let namespace = "default"

postgres.create("temporal") //<4>

const images = new Map([ //<5>
    ["temporalio/auto-setup:1.22.1.0", "localhost:5001/temporalio/auto-setup:1.22.1.0"],
    ["temporalio/ui:2.19.0", "localhost:5001/temporalio/ui:2.19.0"]
])

easykube
    .preload(images) //<6>
    .kustomize()  // <7>
    .waitForDeployment(deployment, namespace) //<8>

easykube.runCommand(deployment, namespace,"tctl", ["--ns", "namespace-a", "n" ,"re"])  //<9>
    .onSuccess((r)=>{console.info(r)})
    .onFail((e)=>{console.warn(e)})

easykube.runCommand(deployment,namespace,"tctl", ["--ns", "namespace-b", "n" ,"re"])
    .onSuccess((r)=>{console.info(r)})
    .onFail((e)=>{console.warn(e)})
----

So, lots of stuff is going on here, lets break it down;

<1> Every addon has a configuration directive, this json structure is extracted by the main easykube program. This is used to construct a Kind cluster configuration.
<2> Addons lets you express dependencies to other addons, in the case of temporal, it needs a database, and an ingress controller for its UI. Internally during addon scan, a graph is created and a topological sort determines the order of installation - just like a build system where tasks depend on other tasks.
<3> The extraPorts contributes to cluster configuration, your deployments should define a NodePort service with the same values. But only if the deployment should be accessible from your host machine (localhost) - In this case we can talk to temporal on `127.0.0.1:7233`
<4> Easykube's public addon repository includes a Postgres database server. This tells postgres to create a database named 'temporal' (if it not already exists). Postgres utility functions lives in the `2-postgres.js` script.
<5> A map if images defines a source and destination.
<6> Here images are fetched from the internet, re-tagged and pushed to the local docker registry. Easykube will not pull images if they already exists in the registry, this saves time (at the expense of more diskusage) Local deployments refer to images in the registry.
<7> Invokes the `kustomize` command, it will render the manifests to a file named `.out.yaml` and then apply it with `kubectl`
<8> This will stop and wait for a deployment to become ready (within a timeout of 30 seconds) - This is useful in a local context as we might have to wait for a database to fully initialized etc. Your real workloads should use a better strategy.
<9> Running arbitrary commands in a container is a useful feature, for instance, this temporal deployment requires namespace-a and namespace-b to be available. You can use this in many scenarios; Load some known testdata into a database, create a token in a container and store it as a kubernetes secret, etc.

== Limitations [[addons-limitations]]

It may appear that the `jslib` is some sort of global context, this is not the case. Every addon is executed in its own context, `jslib` files are simply concatenated and run within the individual addon context.

This means; You cannot share, or have a global state during script execution.

