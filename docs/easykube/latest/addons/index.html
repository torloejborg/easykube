<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Addons :: Easykube Documentation</title>
    <link rel="canonical" href="http://torloejborg.github.io/easykube/easykube/latest/addons/">
    <meta name="generator" content="Antora 3.1.9">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/vendor/asciinema-player.css">

  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">Easykube Documentation</div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<script src="../../../_/js/vendor/asciinema-player.js"></script>
<div class="body">
<div class="nav-container" data-component="easykube" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../">EasyKube</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../">Home</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../rationale/">Why Easykube</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../install/">Install Easykube</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="./">Addons explained</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../using/">Usage</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../internals/">Internals</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../container_runtimes/">Container Runtimes</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../faq/">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../quickreference/">Quick Reference</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Development</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../developing/contributing/">Contributing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../developing/newfunctionality/">Adding new functionality</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../">EasyKube</a></li>
    <li><a href="./">Addons explained</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Addons</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#addons-repositories">Addon repositories</a>
<ul class="sectlevel2">
<li><a href="#addons-dissecting">Dissecting an Addon</a></li>
</ul>
</li>
<li><a href="#addons-limitations">Limitations</a></li>
<li><a href="#addons-author">Author a new addon</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="addons-repositories"><a class="anchor" href="#addons-repositories"></a>Addon repositories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In essence, an addon is a collection of Kubernetes YAML files, Kustomize files, or Helm charts, orchestrated by JavaScript, with built-in dependency management and convenient tooling.</p>
</div>
<div class="paragraph">
<p>Addons are organized in directory structures, typically Git repositories shared within an organization or team. Below is an excerpt from the companion addon repository.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">├── __jslib <i class="conum" data-value="1"></i><b>(1)</b>
│ ├── 1-easykube.js
│ ├── 2-postgres.js
│ ├── 3-utils.js
│ └── readme.md
├── middleware
│ ├── ingress
│ │ ├── ingress.ek.js <i class="conum" data-value="2"></i><b>(2)</b>
│ │ ├── kustomization.yaml
│ │ └── manifests
│ │ ├── default-cert.yaml
│ │ ├── ingress-controller.yaml
│ │ └── namespace.yaml</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The jslib is a core component of a repository. Here, the easykube API is defined as a JavaScript class that wraps function calls and delegates to the _ek object exposed by the Go program. You can write common functionality and place it in this folder.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The addon script determines how the manifests will be applied. In this example we can see that regular Kubernetes YAML files live in subdirectories.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When easykube is invoked, it recursively scans the addon repository and discovers all addons.</p>
</div>
<div class="sect2">
<h3 id="addons-dissecting"><a class="anchor" href="#addons-dissecting"></a>Dissecting an Addon</h3>
<div class="paragraph">
<p>Let&#8217;s examine an addon in detail. We&#8217;ll look at the Temporal addon, as it uses some non-trivial features. Below is its listing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">let configuration = { <i class="conum" data-value="1"></i><b>(1)</b>
"description": "An opensource workflow engine", <i class="conum" data-value="2"></i><b>(2)</b>
"dependsOn" : [ "postgres", "Ingress" ],
"extraPorts" : [ <i class="conum" data-value="3"></i><b>(3)</b>
{
"hostPort" : 7233,
"nodePort" : 30950,
"protocol" : "TCP"
}]
}

let deployment = "temporal-server"
let namespace = "default"

postgres.create("temporal") <i class="conum" data-value="4"></i><b>(4)</b>

const images = new Map([ <i class="conum" data-value="5"></i><b>(5)</b>
["temporalio/auto-setup:1.22.1.0", "localhost:5001/temporalio/auto-setup:1.22.1.0"],
["temporalio/ui:2.19.0", "localhost:5001/temporalio/ui:2.19.0"]
])

easykube
.preload(images) <i class="conum" data-value="6"></i><b>(6)</b>
.kustomize() <i class="conum" data-value="7"></i><b>(7)</b>
.waitForDeployment(deployment, namespace) <i class="conum" data-value="8"></i><b>(8)</b>

easykube.runCommand(deployment, namespace, "tctl", ["--ns", "namespace-a", "n", "re"]) <i class="conum" data-value="9"></i><b>(9)</b>
.onSuccess((r)=&gt;{console.info(r)})
.onFail((e)=&gt;{console.warn(e)})

easykube.runCommand(deployment, namespace, "tctl", ["--ns", "namespace-b", "n", "re"])
.onSuccess((r)=&gt;{console.info(r)})
.onFail((e)=&gt;{console.warn(e)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>A lot is happening here, so let’s break it down:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Every addon has a configuration directive. This JSON structure is extracted by the main easykube program and used to construct the Kind cluster configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a id="addons-dependencies"></a>Addons allow you to express dependencies on other addons. In this case, the Temporal addon requires a database and an ingress controller for its UI. Internally, during addon scanning, a dependency graph is created and a topological sort determines the installation order—similar to a build system where tasks depend on other tasks.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The extraPorts section contributes to the cluster configuration. Your deployments should define a NodePort service using the same values, but only if the deployment needs to be accessible from your host machine (localhost). In this case, Temporal becomes available on 127.0.0.1:7233.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Easykube’s public addon repository includes a Postgres database server. This instructs Postgres to create a database named temporal (if it doesn’t already exist). Utility functions related to Postgres live in the file 2-postgres.js.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A map of images defines a source and destination.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Images are fetched from the internet, re-tagged, and pushed to the local Docker registry. Easykube will not pull images if they already exist in the registry, saving time (at the expense of disk usage). Local deployments refer to images stored in the registry.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Invoking kustomize renders the manifests to a file named .out.yaml and applies them using kubectl.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>waitForDeployment halts execution until the specified deployment becomes ready (with a 30-second timeout). This is useful in local scenarios where we may need to wait for a database to finish initializing. Real workloads should use better readiness strategies.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Running arbitrary commands inside a container is a useful feature. In this example, the Temporal deployment requires namespace-a and namespace-b to exist. This mechanism can be used to load test data into a database, create a token inside a container and store it as a Kubernetes secret, and more.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="addons-limitations"><a class="anchor" href="#addons-limitations"></a>Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It may appear that the jslib is some sort of global context, but this is not the case. Every addon is executed in its own isolated context. jslib files are simply concatenated and evaluated inside that context.</p>
</div>
<div class="paragraph">
<p>This means you cannot share or maintain global state between addons during script execution.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="addons-author"><a class="anchor" href="#addons-author"></a>Author a new addon</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To write your own addon, copy/paste is a reasonable strategy. Alternatively, you can use the built-in skaffold generator:</p>
</div>
<div class="paragraph">
<p><code>$ easkube skaffold --name myaddon --location utils</code></p>
</div>
<div class="paragraph">
<p>This generates a simple addon skeleton you can adapt for your own purposes. The location parameter is relative to the root of the addon repository.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using a customized version of Antora default UI.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
